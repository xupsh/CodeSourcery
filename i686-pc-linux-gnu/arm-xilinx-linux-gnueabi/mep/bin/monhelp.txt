##########################################################################
##
##  MON Command Language help file:
##
##  DO NOT USE TABS IN THIS FILE!!!!!!!!!!!!!!!!!!
##  When merging, make sure you don't merge in tabs again.
##
##  - Comments and #if/#ifall/#endif/#else(s) can be used anywhere, but the
##    line must start with a # ( in column 1 ).
##  - Nested #if statements are permitted.
##  - #if has the form   #if { [!]keyword }...
##        where keyword is one of the words listed below.
##  - If more than one keyword is specified, they will be logically or'ed
##    together on a #if line and and'ed together on a #ifall line.
##  - To make sure the help file has all the correct syntax, invoke
##      mon and do a 'h [gen]' command.
##  - The CURRENT LEGAL KEYWORDS ARE :     NOTE --** CASE SENSITIVE **--
##
##    CPU family:       ARM      MIPS	PPC     
##
##    CPU Attributes:   HAS_TLB  FPU_EVEN  FPU_SINGLE  FPU_DOUBLE
##
##    MIPS CPU groups:  MIPS_3K   MIPS_4K
##    MIPS CPU's:       R(each processor number)
##
##    Host OS's:        LINUX  WIN32
##
##    Target Vehicals:  ICE      SIM
##    TV sub-types:     MEP
##
##    Debuggers:        MON      CDB       API
##
##  - To add a new keyword to the list - see procedure init_keywords in
##         dbg\lib\cmn\moncmds3.c
##  - If you have problems reading the help file, a help file preprocessor
##    tool has been created to generate a readable text file with no
##    preprocessor commands using specified keywords.  See filter.exe.
##    This preprocessor should also be run to check your changes to
##    the help file.
##  - Color is intended to indicate 1) that the user can get a help screen
##      on the colored word and 2) general emphasis (header on group screen).
##   - COLOR SUPPORT: When trying to align columns that contain tildes, be
##     aware that even though you see them, they do not print (see
##     'H FMT_OPTIONS').
##
##########################################################################
#
#if MON API
.  b
                        ~Breakpoint commands~

   BC   Clears all Breakpoints, or clears breakpoints at specified addresses
   BL   Lists the status of all Breakpoints
   BS   Sets Software Breakpoints at specified addresses, with optional pass
        counts
   BS2  Sets MIPS16/Thumb Software Breakpoints at specified addresses, with
        optional pass counts
   BSH  Sets a Hardware Breakpoint with specified conditions and optional
        pass counts

   +B   Enables all Breakpoints, or enables breakpoint at specified addresses
   -B   Disables all Breakpoints, or disables breakpoint at specified addresses

.  bc
Syntax :  BC [ * | { # ~number~ | ~addr~ }... ]

Description :  The Breakpoint Clear command clears one or more breakpoints
    previously set with the BS command.  BC with no arguments will clear
    the software breakpoint at the current execution address.

    *  indicates that ALL breakpoints are to be cleared.
        Otherwise, only the specified breakpoints are cleared.

    ~addr~ gives the address of a specific software breakpoint to be
        enabled or disabled. ~addr~ must be an address in a valid code address
        space.  See "H ADDR" or "H EXPR" for valid address forms.

    ~number~ gives the breakpoint ID number (as shown by BL) of a specific
        software or breakpoint to be enabled or disabled.

.  bl
Syntax :  BL

Description :  The Breakpoint List command displays a list of all breakpoints
    currently set, showing the break address, remaining pass count, initial
    pass count, active/inactive,  and the associated command list.  If a
    non-empty command list has been specified on a previous Go or Step
    command, it will also be displayed.

.  bs bs2
Syntax :  BS[2] [ ~addr~ [ , [-]~number~ ] ] ...  [ "{" ~cmd_list~ "}" ]

Description : The Breakpoint Set command sets one or more software breakpoints
    with optional pass counts and an optional command list.  BS sets normal
    breakpoints and BS2 sets MIPS16/Thumb mode breakpoints.  If no pass count
    is specified, a value of one is assumed.  If a negative pass count is
    specified, the breakpoint is temporary: it will be removed automatically
    when it is taken.  The program will be interrupted each time the break
    address is reached <number> times.  At that time, the command list will be
    executed.  There is no limit on the number of active breakpoints.

    ~addr~ must be an address in a valid code address space.
        See "H ADDR" or "H EXPR" for valid address forms.

    ~number~ is by default decimal.  See "H NUM" for available number forms.

    ~cmd_list~ is any valid command list, with G or S being last if present.
.  bsh
Syntax :  BSH ~options~ [ ~size~ ] [ ~asid~ ] ~arange~ [ # ~mask~ ]
              [ = ~vrange~ [ # ~mask ]] [ , [-]~number~ ]  [ "{" ~cmd_list~ "}" ]

Description :  The Breakpoint Set, Hardware command sets a hardware breakpoint
    with an optional pass count and an optional command list.  If no pass
    count is specified, a value of one is assumed.  If a negative pass count
    is specified, the breakpoint is temporary: it will be removed automatically
    when it is taken.  The program will be interrupted each time the break
    address is reached ~number~ times.  At that time, the command list will be
    executed.  The actual number of hardware breakpoints available, and the
    options which can actually be used to condition them, is dependent on the
    target CPU's capabilities.

    ~options~   { I | R | W | S | A | T | B }...
        Flag word consisting of one or more of the following letters:
           I - Break on matching instruction fetch
           R - Break on Data Read
           W - Break on Data Write
           S - Size qualifier present, break only if access matches
           A - ASID qualifier present, break only if access matches
           T - Generate a Tracepoint signal without stopping.
           B - Break on Tracepoint (redundant unless T also given)
    ~size~      { 8 | 16 | 32 | 64 }
        access size, required if ~options~ has 'S', else invalid
    ~asid~      ~number~
        ASID value, required if ~options~ has 'A', else invalid

    ~arange~    [ ~addr~ [ ~addr~ ] | ~addr~ L ~number~ ] (See "H RANGE")
        Memory address or address range which will trigger the breakpoint.
        See "H ADDR" or "H EXPR" for valid address forms.  If the
        "~addr~ L ~number~" syntax is used, ~number~ is scaled by ~size~ if
        specified, else it is taken as a byte count.  This parameter is
        required, but a mask of 0 can be applied if the break should not
        be conditioned on the address (e.g. fetching a certain value from
        any address).  

    ~vrange~    [ ~value~ [ ~value~ ] | ~value~ L ~number~ ] (See "H RANGE")
        Value or range of values which will trigger the breakpoint when
        accessed.  See "H VALUE" for valid value forms.  If the
        "~addr~ L ~number~" syntax is used, ~number~ is taken as a byte count.

    ~mask~ is by default hexadecimal.  See "H NUM" for available number forms.
        Bitmask applied to the address or value range as part of the
        breakpoint condition.  Zero bits in ~mask~ are don't care bits when
        testing the address or value.

    ~number~ is by default decimal.  See "H NUM" for available number forms.

    ~cmd_list~ is any valid command list, with G or S being last if present.
#endif /* MON */
#if MON
.  c
Syntax :  C [ ~max_levels~ ]

Description :  The Call summary command causes a traceback of the current
    function call chain to be displayed.  It assumes that the program
#if ARM
    under test follows the ARM calling conventions.
#endif  /* ARM */
#if PPC
    under test follows the PowerPC calling conventions.
#endif  /* PPC */
#if MIPS
    under test follows the calling convention specified by the
    "calling_convention" EO option.
#endif  /* MIPS */
    This will be true for C programs, but adherence to the standard
    calling convention is the responsibility of the programmer for
    assembly language programs.

    For each function in the call chain, the call summary contains the
    address of the next instruction to be executed, in hex and symbolically,
    and the current contents of the local registers that contain the
    function's arguments, if any.  For static (non-global) functions, the
    name of the function may not be known, in which case the closest preceding
    global symbol will be displayed along with an offset.  This command is
    useful, not only to see how control got to its current location, but also
    as a convenient way to find where to set a breakpoint to interrupt
    execution when a function returns to its caller.

    ~max_levels~ is a number giving the maximum number of stack levels to be
       listed (default 15).
#endif  /* MON */
#if TV_CACHEOPS
.  cf ci cfi
Syntax :  CF [ D ]
          CI [ I | D ]
          CFI [ I | D ]


Description :  The Cache commands perform basic operations on the processor's
    main caches.  Cache Flush (CF) flushes the cache by causing all "dirty"
    entries to be written back to main memory.  It is meaningful only for data
    caches that support write-back mode.  Cache Invalidate (CI) marks all
    entries in the cache(s) invalid, discarding any modified data in a write-
    back data cache.  Cache Flush & Invalidate (CFI) invalidates the cache(s)
    after flushing any modified data to main memory.

    I | D   specifies that the operation should be applied to the Instruction
        or Data cache.  If neither is specified, both Instruction and Data
        caches are affected.
#endif
.  d
                        ~Display commands~

   DA   Display currently defined command Aliases
   DI   Display sign-on message and Initialization information
   DM   Display MMU table / translate address
   DN   Display Names (symbols)
   DO   Display configuration Options
   DS   Display Scripts
   DV   Display Values according to format specifications

   DB   Display/Find Byte size objects in specified range
   DH   Display/Find Half-word size objects in specified range
   DW   Display/Find Word size objects in specified range
   DD   Display/Find Double size objects in specified range
   DQ   Display/Find Quad size objects in specified range

#if TV_TCIM
   DTR  Display Trace Ranges
#endif
#if TV_TRACE

   DT   Display captured Trace data
   DTN  Display Trace Name
   DTF  Display Trace display format information
   DF   Display defined Filters (used in displaying trace data)
#endif
.  da
Syntax :  DA [ * | ~alias~ ]

Description :  The Display Alias command shows the name and replacement text
    for one or all currently defined Aliases.  See "H EA" for more information
    about aliases.

    * means display all aliases.  This is the default.

    ~alias~ is the name of a specific command alias

.  di
Syntax :  DI

Description :  The Display Initialization command shows the version number
    and the setup and configuration information stored in the Initialization
    file associated with the target.


.  dv
Syntax :  DV ~format_string~  [ , ~addr_expr~ ]...

Description :  The Display Value command allows the user to generate formatted
    output.  The format_string controls the operation of DV much like the
    format string in a C printf() statement.

    ~format_string~ is a string literal, enclosed in quotation marks, containing
      characters to be displayed (including C-style escape sequences) and
      conversion specifiers.  Conversion specifiers follow C conventions
      EXCEPT: the size of the object to be displayed can be specified using
      the 'B', 'H', and 'W' (or 'L') qualifiers, and the use of '*' to specify
      a dynamic field width is not supported.

      The size and conversion format specifiers combine to determine whether
      the value of the ~addr_expr~ or its content will be displayed:
        s, e, f, g : always display data stored at address addr_expr
        all others : display the value of the addr_expr UNLESS an object size
                     is supplied, then they display the object at addr_expr.
Examples:
#if ARM | PPC 
    BS printf { DV "In printf, args = \"%s\", %d, %ld\n",@r1,@r2,r3 ; G }
#endif  /* ARM | PPC */
#if MIPS
    BS printf { DV "In printf, args = \"%s\", %d, %ld\n", @a0, @a1, a2 ; G }
#endif  /* MIPS */
    DV "Byte at %x is %02bx\n", global_char_var, global_char_var

.  db  dq dd  dh  dw find search
Syntax :  D[ ~type~ ][ R ] ~range~ [ ,~fmt~ ]  [= ~value~[#~mask~] [, ~value~[#~mask~]]...]

Description :  The Display command displays the contents of the specified
    registers or memory locations.  If a value list is given, Display searches
    memory for those values.  Once a Display command has been entered, it may
    be repeated (for successive addresses) simply by hitting the <enter> key,
    UNTIL another command is entered or, when searching, UNTIL end of ~range~.

    ~type~, which defines object size, has the form : { B | H | W | D | Q }
        default is type in previous Display ( or W on first Display ).

    R   causes reverse searching ( search starts at the end of the range ).

    ~range~ has the form : [ [ ~addr~ ] L ~number~ | ~addr~ [ ~addr~ ] ] (See "H RANGE")

    ~fmt~ has the form : { d | u | o | x | X | f | e | E | g | G | c | s | i 
                           | I }
        Default is "X" (hex).  See "H FMT" for description of choices.
    Valid ~type~/~fmt~ combinations are listed in the manual.  See "H TYPE".

    ~mask~ is a hex value that specifies which bits of value should be compared
        with memory.  If mask is supplied only for the last value in the list,
        it will apply to all values in the list.  ~mask~ / finds are not 
        supported on quad word objects (DQ command).

#if TV_TC3D
.  df
Syntax :  DF  [ { * | filter_list } ]

Description :  The Display Filters command displays the trace display filters,
     and indicates their active/inactive status.

    *  means all filters.  This is the default.

    ~filter_list~ has the form : { F~id~[:~id~] } ...     (See "H LIST" for details)
    ~id~ has the form : { 1..50 | ~label~ }
    ~label~ has the form : ${ A-Z | a-z | 0-9 | _ }...    (15 character limit)

#endif  /* TV_TC3D */
.  ds dsv dsq
Syntax :  DS[Q|V] [~file_spec~]

Description :  The Display Scripts command displays the name and call entry
    points of any MEP script files found on the current search path. In verbose
    mode, each directory searched is identified/displayed. The default script
    files extension is .maj and if no file extension is given then only .maj 
    files are shown, otherwise only files matching the given extension are 
    shown. 

    Q            means Quiet mode.
    V            means Verbose mode.

    ~file_spec~ has the form : { A-Z | a-z | 0-9 | _ | . | * }...    

#if TV_TCIM
.  dtr
Syntax :  DTR [ * | ~range~ ]

Description :  The Display Trace Ranges command displays the address ranges
    where tracing is currently enabled.  By default DTR displays all currently
    active Trace Ranges, or it can display only those within a specified range.
    Each range will be displayed as originally entered, and the resulting
    actual traceable regions (after widening, see "H ETR") are also shown.

    *  means all current Trace Ranges.  This is the default.

    ~range~ has the form : [ [ ~addr~ ] L ~number~ | ~addr~ [ ~addr~ ] ] (See "H RANGE")

#endif  /* TV_TCIM */
.  dm dmx dmxv
#if ARM
Syntax :  DM     [ num [x] ]
          DMX[V] ~addr~
#else
Syntax :  DM
          DMX ~addr~
#endif

Description :  Displays the current target virtual-physical memory map (MMU)
    setup in the CPU page descriptor tables or (DMX) translates the given 
    virtual address to physical. On MIPS targets the built in hard-mapped 
    memory segments (kseg0/1) are also displayed. 
#if ARM

    V            means Verbose mode and displays MMU table translation details.

    ~addr~         is a virtual address in the default space.

    num          is a number: { 0-3 }
                 0 - displays mixed table (same as no num provided case)
                 1 - displays mixed and mapped tables
                 2 - displays mixed and not mapped tables
                 3 - displays mixed, mapped and not mapped tables

    x            is any argument and cause extra MMU table information to be
                 displayed.
#endif

.  do  doq dov
Syntax : DO[Q|V] [ * | ~pattern~ | ~option~ ]

Description : The Display Options command displays the name, _current_ value,
    and description of one or more of the options that control the appearance
    and default actions of the debug monitor.  In verbose mode, DO also 
    displays the default value and the range of valid values for each option.
    Verbose mode also displayed the expanded version of the option's 
    description.  Quiet mode displays just the name and value.

    Q            means Quiet mode.
    V            means Verbose mode.

    *            means all options.  This is the default.

    ~pattern~      has the form  : { { A-Z | a-z | _ }...}*
                 All of the options whose long_name matches this pattern
                 will be displayed.

    ~option~       is a valid debugger configuration option.  It can be
                 referenced by either its ~long_name~ or ~short_name~.

         ~long_name~    is the entire option name
         ~short_name~   is the abbreviated option name.  Options may be
                      abbreviated by their initials.

                      Examples: dp_color_err_msg      ->   dcem
                                om_169_second         ->   o1s

#if TV_TRACE
.  dt
Syntax :  DT [ ? | { {+|-}[~count~] } | ~span~ ] [,{R|I|D|M}[A|R|D|N]]

Description :  The Display Trace command allows the user to request a list
    of the available frames and the current pointer, to display frames
    relative to the current pointer or to display specific frames by number.
    Once a Display Trace command has been entered, hitting the <enter> key
    will display the next screenfull of frames in the current direction,
    UNTIL some other command is entered. The display mode remains in effect
    until changed.

    ?  means report available frames and the current pointer

    { + | - } [ ~count~ ]  sets the default paging direction and displays the
         next screenfull of frames or one starting "count" displayable frames
         away.
    ~span~ has the form:  { ~start~ [~end~] } | { [ ~start~ ] L ~count~ }
         ~start~ ~end~  displays frames start to end, inclusive,
         ~start~ L ~count~  displays "count" frames forward from start,
         L ~count~  displays "count" frames in the current paging direction.
         '$' specified for ~start~ or ~end~ means last frame.
    R | I | D | M  sets the display mode: Raw | Instruction | Data | Mixed
    A | R | D | N  sets the timestamp display mode:
         Absolute | Relative (to first frame) | Delta (between frames) | None
         The default is Relative for Raw mode, None for the rest.
.  dtn
Syntax : DTN [ * | ~pattern~ | ~f_name~ ] [ L ~n~ ]

Description : The Display Trace Name command displays the f_names.

    *            means all f_names.  This is the default.

    ~pattern~    has the form  : {{ A-Z | a-z }...}*
                 All the f_names which match this pattern will be displayed.

    ~f_name~     is one of the defined f_names.

    ~n~    specifies the number of trace names to include in this display. The
           default is to display all the f_names which match the pattern
           specified.

           Note that an '*' displayed next to an f_name indicates that it
           is user-defined.

.  dtf
Syntax :  DTF [ * | ~pattern~ | ~f_name~  | ~s_name~ ] [ L ~n~ ] [ ~m~={R|F} ]

Description : The Display Trace Format command displays the current trace
    format definitions.

    *    means all formats.  This is the default.

    ~pattern~ has the form  : {{ A-Z | a-z }...}*
              All the formats which match this pattern will be displayed.

    ~f_name~  is one of the defined f_names.

    ~s_name~ is one of the special names defined by MON on startup.
     (See "H S_NAME" for more info)

    ~n~    specifies the number of formats to include in this display. The
     default is to display all the formats which match the pattern specified.

    ~m~ is the mode indicator.  The formats will be displayed for RAW or
     FORMATTED mode depending on this indicator.  Default is based on the
     current trace display mode.

     Note that the '+' or '-' displayed next to each format indicates if
     it is enabled or not.
#endif
.  e
                        ~Enter commands~

   EA   Enter a command Alias
   EO   Enter configuration Options
#if !CDB
   EN   Enter Name (symbol)
#endif

   EB   Enter/Fill Byte size objects in specified range
   EH   Enter/Fill Half-word size objects in specified range
   EW   Enter/Fill Word size objects in specified range
   ED   Enter/Fill Double size objects in specified range
   EQ   Enter/Fill Quad size objects in specified range

#if TV_TCIM
   ETR  Enter Trace Ranges
#endif
#if TV_TRACE

   ETN  Enter Trace Name (used in trace format)
   ETF  Enter Trace display format information
   EF   Enter Filter (for display of trace data)
#endif

.  ea alias
Syntax :  EA ~alias~ ~cmd_list~

Description :  The Enter Alias command enters a new alias in the alias table.
    Aliases allows you to create your own custom commands from combinations
    of existing commands.  After an alias has been created with EA, the alias
    name can be used as if it were a built-in command.  When an alias command
    is executed, the alias name is replaced with the command list specified
    on the EA command.  The replacement text will be followed by whatever
    followed the original alias command.  Alias commands may be nested, but
    recursion is not allowed.

    ~alias~ is the name of the new composite command.

    ~cmd_list~ is one or more commands separated by semicolons.

    For example, to build and use a shorthand command for reading command
    files, you might do:
             "EA RC FR C "
             "RC foo.maj"   

.  eb  eq ed   eh   ew  ebk  edk   ehk   ewk  fill
Syntax :  E[ ~type~ ][ K ] [~range~] [ ,~fmt~ ] [= ~value~ [, ~value~]...]

Description :  The Enter command allows the contents of the specified
    registers or memory locations to be altered.  If a value list is given,
    Enter immediately writes the values, repeating them if necessary to fill
    the range.  Otherwise, Enter displays the current value of each object in
    turn, prompting for a new value.  If range is not supplied, Enter picks up
#if MIPS
    where the last Enter left off. Enter with "i" fmt invokes a mini-assemqbler
#else
    where the last Enter left off. 
#endif
    ~type~, which defines object size, has the form : { B | H | W | D }
        default is type in previous Enter ( or W on first Enter )

    K   causes input to be read directly from the Keyboard, even when reading
        commands from a ~command~ file.  It is ignored if "= ~value~..." is given.

    ~range~ has the form : [ [ ~addr~ ] L ~number~ | ~addr~ [ ~addr~ ] ]
        See "H ADDR" or "H EXPR" for valid address forms.

    ~fmt~ has the form : { d | u | o | x | X | f | e | E | g | G | c | s | i }
        Default is "X" (hex).  See "H FMT" for description of choices.
        Valid ~type~/~fmt~ combinations are listed in the manual. See "H TYPE".

    Note: Only hex input values are supported for quad word writes (EQ command)
          A quad word vale may be separated '.' at the double word value.
#if TV_TRACE
.  ef  filter  filters  clause
Syntax :  EF[ ~id~ ] [ ~label~ ]  ~filter_clause~ [ & ~filter_clause~ ]... 

Description : The Enter Filter command allows the user to define filters.
   A filter is a set of clauses that define states, values or ranges of values
   for particular Trace Names.  Multiple filters may be active at the same
   time.  When filtering is enabled, only those frames which satisfy all of
   the clauses of any active filter will be displayed.  This can be very useful
   in finding a particular frame of interest in the trace buffer.  Once the
   frame is located, filtering can be disabled (using -F) or modified to allow
   the surrounding frames to be seen.

    ~id~ has the form : { 1..50 | ~label~ }
    ~label~ has the form : ${ A-Z | a-z | 0-9 | _ }...    (15 character limit)

    NOTE!!!  If a numeric id is not specified, the next available filter
    number will be assigned.

    ~filter_clause~ has the same basic form as an f_spec.

          for "single bit" Trace Names       [ ! ]TN 
          for "grouped signal" Trace Names   [ ! ]TN = ~value~
          for "field" Trace Names            [ ! ]TN = ~range~[ #~mask~ ]
          for ~s_names~ location & value       [ ! ]SN = ~range~[ #~mask~ ]

    For any "single bit" Trace Name, we assume that it is active high, unless
    the Trace Format separator associated with it is a minus sign ('-').
#endif  /* TV_TRACE */
.  eo
Syntax : EO ~option~ = ~value~

Description : The Enter Options command allows configuration of various
     debugger options, which control the appearance and default actions
     of the debug monitor.

    ~option~       is a valid debugger configuration option.  It can be
                 referenced by either its ~long_name~ or ~short_name~.

         ~long_name~    is the entire option name.
         ~short_name~   is the abbreviated option name.  Options may be
                      abbreviated by their initials.

                      Examples: dp_color_err_msg      ->   dcem
                                trgt_little_endian    ->   tle

     For a list of configuration options, invoke the DO command.
     For information on the standard default and valid values of a 
     particular option, invoke the DOV command followed by the option name.

     Options and option enum values can be referenced in expression by using 
     a $ as leadin to the name.  $ is also used for debugger local variables,
     but options have higher precedence.  Below is an example option expression

     if ( @$lep == $lep.yes ) { dv "PC is initialized at load time\n" };
#if TV_TRACE
.  etm
Syntax :  ETM  { R | I | D | M }

Description :  The Enter Trace Mode command changes the current trace
    display mode.  This command can be used instead of specifying a mode with
    the 'DT' command.  The trace display mode affects not only display trace 
    command but also the trace format ('DTF') command.  The 'M', 'I', and 'D'
    parameters will the change the mode of the 'DTF' command to 'formatted'.

    parameter    trace display mode     trace format mode

       R               Raw                    Raw
       I            Instruction             Formatted   
       D               Data                 Formatted   
       M              Mixed                 Formatted   

.  etn
Syntax :  ETN ~f_name~  ~f_list~

Description :  The Enter Trace Name command is used to define trace names.
    Trace names are used when defining Trace Formats with the ETF command
    and when defining trace display Filters.

    ~f_name~ specifies a new or existing trace name to be defined.  This can
             not be one of the default f_names - those can not be overwritten.
             A user-defined f_name is treated as a pin, field or group based on
             its f_list.  If the f_name is more than 15 characters, it will be
             truncated.

    ~f_list~ has the form : { f_atom | f_name } [ [&] f_list ]
             The f_list cannot be more than 32 bits wide.  All the f_names
             specified in the f_list will get concatenated together when used
             in trace display.  The result will be treated as a single value.
             Note that an f_name being re-defined can be part of an f_list.

    ~f_atom~ is a pin,field,field range,field_bit,group,group range,group bit.
#if MIPS_3K
             examples (in order) : ALE, A, A3:0, A0, TSTATE, TSTATE1:2, TSTATE3
#endif
#if MIPS_4K
             examples (in order) : RDRDY,AD,AD3:0,AD0,TSTATE,TSTATE1:2,TSTATE3
#endif
.  etf
Syntax :  ETF { ~f_name~ | ~s_name~ } [ ~fmt_options~ ]

Description :  The Enter Trace Format command is used to define trace formats.
    Trace formats allow the user to customize the trace display for specific
    needs.  Each format specifies all the attributes of a particular trace
    display column.

    ~f_name~ must exist before using this command.  F_names can be defined
     using the 'ETN' command.

    ~s_name~ is one of the special names defined by MON on startup.
     (See "H S_NAME" for more info)

    ~fmt_options~ take the form [key = value ] and are all optional.  Those
     options which are not specified will remain unchanged for existing
     formats, and will be calculated by MON for new formats.
     (See "H FMT_OPTIONS" for more info)

#endif /* TV_TRACE */
.  f  fr  fw
#ifall !TV_TC3D TV_TRACE 
Syntax: FR {C|RD|M|TD|TF} ~file_name~ [~addr~] [~p_value~]...
        FW[A|O] {O|C|M|TD|TF} {~file_name~|-|+} [~range~]
#endif
#ifall !TV_TC3D !TV_TRACE 
Syntax: FR {C} [:]~label~ [~p_value~]...
	FR {C} ~file_name~[:~label~] [~p_value~]...
        FR {RD|M} ~file_name~ [~addr~] [~p_value~]...
        FW[A|O] {O|C|M} {~file_name~|-|+} [~range~]
#endif
#if ARM
        FW[A|O] {MDI|RDI} {~file_name~} 
#else
        FW[A|O] {MDI} {~file_name~} 
#endif

Description :  The File command allows the user to read or write a file.

    FR  means read the indicated file
    FW  means write the indicated file
    A|O means append to | overwrite indicated file unconditionally
                                                  Default file name extension:
    O   means an Output capture file (write only; see "H FWO")        ".out"
    C   means a Command file (read or write; see "H FRC" or "H FWC")  ".maj"
    RD  means a Register Definition file (read only)                  ".rd"
    M   means a Memory image file (binary or Motorola s-record file)  ".mem"
#if TV_TRACE
    TD  means a Trace Display file                                    ".td"
    TF  means a Trace Format file                                     ".tf"
#endif
    MDI means a MDI Configuration file				      ".cfg"
#if ARM
    RDI means a RDI Configuration file				      ".cfg"
#endif
    ~file_name~ is pathname of the file to be read or written.  The default
        file name extension listed above will be added if none is supplied.
    -/+   means to suspend/restart writing to file ( O and C only )

    ~range~ and ~addr~ specify the range of data to be written to (FW M), or
        the address to store data read from (FR M), a Memory image file.

    ~p_value~ is a parameter value (valid only with "FR C")
.  frc
Syntax :  FR C  ~label~  [ ~p_value~ ]....
	  FR C  ~file_name~[.~label~]  [ ~p_value~ ]....

Description :  This subcommand causes the debug monitor to read ~commands~
    from the specified file or position within a file identified by a label.
    If only a label is supplied then the current file is assumed.  When all 
    the commands in the file have been processed or a return command has 
    been encountered, the monitor resumes reading commands from its previous
    input source, ultimately returning control back to the console.  This is
    an easy way to input a standard set of commands or to quickly recreate an
    earlier session.  The file can be created manually or can be the result
    of the File Write (FW C) command.  If the FR C command is part of a
    multi-command line, the remaining commands on the line will be executed
    after all commands in the new file have been executed.

    ~file_name~ is pathname of the file to be read.

    ~label~ is a label within the referened ~file_name~.

    ~p_value~ is a string which will be substituted for a parameter in the
       command file.  A parameter is of the form: $$n, with 1 <= n <= 99.
       See "H PARAM" and "H SHIFT" for more details.

    Note: Referencing labels allow for a function call like processing and a
         ~label~ has precedence over a ~file_name~ in this context.  Also note
          that a label function call can be done without using "FR C" as
          a direct command, but this method only allows references to labels
          that have been identified as function labels by the use of two :'s
          in front of the label declaration.

    Command files may be nested up to 20 levels deep.

.  fwc
Syntax :  FW[ A | O ]  C  { ~file_name~ | + | - }

Description :  This subcommand copies the user's commands into
    the specified file.

    A  means append to specified file, unconditionally.
    O  means overwrite specified file, unconditionally.

    ~file_name~ is the pathname of the file to be written to. Copying starts
    immediately.

    -  causes copying to stop temporarily and the file to be closed.
    +  causes copying to start again, after being interrupted by a "FW C -".

    If the specified file already exists, you will be given the opportunity
    to overwrite or append to the file, or to cancel the File Write command,
    unless A or O has been specified.

.  fwo
Syntax :  FW[ A | O ]  O  { ~file_name~ | + | - }

Description : This subcommand causes each line printed to the
    console to be echoed in the specified file.

    A  means append to specified file, unconditionally.
    O  means overwrite specified file, unconditionally.

    ~file_name~ is the pathname of the file to be written to. Echoing starts
    immediately.

    -  causes echoing to stop and the file to be closed.
    +  causes echoing to start again, after being interrupted by a "FW O -".

    If the specified file already exists, you will be given the opportunity
    to overwrite or append to the file, or to cancel the File Write command,
    unless A or O has been specified.

#if MON
.  g gi
#if TV_CONCURRENT
Syntax :  G[I] [ =~addr~ ] [ ~addr~ ... ] [ "{" ~cmd_list~ "}" ]
#else
Syntax :  G [ =~addr~ ] [ ~addr~ ... ] [ "{" ~cmd_list~ "}" ]
#endif

Description :  The Go command starts the execution of the program.  Execution
    continues until a breakpoint or the end of the program is encountered.
    If a command list is given, it is executed every time execution stops.  It
    remains in effect until cancelled by a Step or Go command with an empty
#if !TV_CONCURRENT
    command list (e.g. "S {}").
#else
    command list (e.g. "S {}").  The I option starts execution in interactive
    mode.  This mode changes MON's prompt to "MON(r)>" and allows 
    debugger commands to be entered while the program is executing. The SP 
    (stop) command interrupts the running program and returns MON to normal 
    debug mode (prompt = "MON>").  See "H INTERACTIVE" for more details on
    this mode.
#endif

    If =~addr~ is specified, execution begins at that address.
        Otherwise it begins at the current Program Counter location.

    The other addresses on the command line specify temporary breakpoints,
        which will disappear when execution stops.

    ~addr~ must be an address in a valid code address space.
        See "H ADDR" or "H EXPR" for valid address forms.

    ~cmd_list~ is any valid command list.
#endif  /* MON */

.  label labels function call calls
Syntax :  :~label~                                 ( label definition )
	  ::~label~                                ( function label definition )
	  ~file_name~[:~label~] [ ~p_value~ ]....      ( label reference  )
	  ~label~ [ ~p_value~ ]....                  ( label reference  )

    ~label~ is a C-type identifier.  A label is defined by entering
    ":~label~" on a line by itself and a function label is defined by
    the use of two :'s ("::~label~").  Syntax for a C-type identifier is
           { A-Z | a-z | $ | _ } [ { A-Z | a-z | 0-9 | $ | _ | . } ]...

Description :  A label can be the target of a GOTO command, "FR C" script
    call, but not a direct call reference.  A function label can be the
    target of any of these.  Below is an example command file with 
    label functions:

    // Example maj command file: test.maj
    return         // main script entry point is unused 
    ::boo  // Function boo
      dv "Entering script function boo - argument: %d\n", $$1
      return       // return from call
    ::foo  // Function foo
      dv "Entering script function foo\n"
      test.boo 1   // call function boo using script file qualification
      boo 2        // call function boo within current script
      return       // return from call
    // End test.maj

    Note the example label function calls from inside function foo.  Below
    are example external (must reference script file) function calls.

    MON> test.foo   // call function foo in script file test.maj
    MON> test.boo 3 // call function boo in script file test.maj with one arg

.  goto  
Syntax :  GOTO ~label~                                      ( label reference  )

Description :  The GOTO command implements non-sequential reading of a
    ~command~ file.  It repositions the file pointer to the command immediately
    following the referenced ~label~.  Note that label can also be function
    callable via the "fr c" command or by direct reference. 

    Example :

      EW $loop = 0                      /* initialize debugger variable */
      :TOP
      S 1000 ; DW x                     /* look at variable every so often */
      IF (@x > 0xffff) { GOTO BOOM }    /* Has it been trashed yet? */
      EW $loop = @$loop + 1             /* Update loop count */
      IF ( @$loop < 1000 ) { GOTO TOP } /* Loop, but don't go forever */
      GOTO DONE                         /* Is working, exit cmd file */
      :BOOM                             /* "x" got trashed */
      DW $loop                          /* loop count when we noticed trash */
      DW x
      :DONE
.  h
Syntax :  H [ ~command~ | OPS | ~op_key~ | CONTROL ]

Description :  The Help commands displays general or specific information
    about the debug monitor commands and operands.

    If no parameter is not supplied, a brief summary of each command
        is displayed.

    If ~command~ is specified, the syntax and description of that command is
        displayed, along with basic information about its operands.

    If OPS is supplied, a list of operands for which help screens exist
        is displayed, along with their op_keys.

    If an ~op_key~ is supplied, the syntax and description of the specified
        operand is displayed.

    If CONTROL is supplied, a list of flow control features for command
        files is displayed.

.  if
Syntax :  IF  ~addr_expr~  "{" ~cmd_list~ "}"   [ "{" ~cmd_list~ "}" ]

Description :  The IF command implements conditional execution of monitor
    commands, in a ~command~ file.  The ~addr_expr~ is evaluated and if
    it is true, the first command list is executed.  If it is not true and
    a second command list is present, the second command list is executed.

    In the evaluation of ~addr_expr~,  a symbol evaluates to its address UNLESS
    preceded by an indirection operator ('@'), in which case it evaluates
    to its contents.  True is defined as non-zero.  See "H EXPR" for more
    information on address expressions.

    ~cmd_list~ is any valid command list.

.  k
                        ~Kill commands~

   KA   Kill Aliases
#if !CDB
   KN   Kill Names (symbols)
#endif /* !CDB */

#if TV_TCIM
   KTR  Kill Trace Ranges
#endif
#if TV_TRACE

#if TV_TCIM
   KT   Kill Trace data
#else
   KT   Kill Trace Specification and Trace Display
   KTD  Kill Trace Display
#endif
   KTF  Kill Trace Format
   KF   Kill Filters
#endif

.  ka
Syntax :  KA { ~alias~ | * }

Description :  The Kill Alias command deletes the name and replacement text
    for one or all currently defined Aliases.  See "H EA" for more information
    about aliases.

    ~alias~ is the name of a specific command alias

    * means kill all aliases

#if TV_TCIM
.  ktr kts
Syntax :  KTR { * | { ~range~ [ , ~range~ ]... } }

Description :  The Kill Trace Ranges command deletes some or all of a trace
    control setup.  KTR deletes all current Trace Ranges in the specified
    address range(s)

#endif
#if TV_TRACE
.  kt ktd
Syntax :  KT[D] [ Y ]

Description :  The Kill Trace command deletes the captured trace data.

    KT and KTD have the same effect.  These commands will normally prompt you
    to verify the deletion. Press 'Y' to proceed or 'N' to abort.  Or you can
    avoid the prompt by supplying a confirming "Y" as a parameter in the Kill
    command.  This is useful in ~command~ files.

.  kf
Syntax :  KF { * | ~list~ }

Description :  The Kill Filter command deletes some or all of the current trace
    display filters.

    *  indicates that all filters are to be deleted.
    ~list~ is a filter_list, specifying filters to be deleted.  (See "H LIST")

.  ktn
Syntax :  KTN { ~f_name~ | * } [Y]

Description :  The Kill Trace Name command deletes user-defined trace
    names and their associated trace formats.

    ~f_name~ must be user-defined.  The f_name will be removed as well as
     ALL of its associated trace formats.

    Y auto respond yes to questions.

.  ktf
Syntax :  KTF { ~f_name~ | ~s_name~ | * } [m={R|F|RF}] [Y]

Description :  The Kill Trace Format command deletes individual trace
    display columns from the format or all columns.  Only user defined
    formats can be killed.  If this command is used with a permanent ~f_name~,
    it will restore the format's original settings and position.

    ~f_name~ must exist before using this command.

    ~s_name~ is one of the special names defined by MON on startup.
     (See "H S_NAME" for more info)

    *    specifies that all user-defined formats will be deleted, and the
         default formats will be restored.

    ~m~ is the mode indicator.  The formats will be deleted for RAW, FORMATTED
     or both modes depending on this indicator.  Default is based on the
     current trace display mode.

    Y auto respond yes to any questions.

#endif
#if !CDB
.  l
Syntax :  L [[-[n]o ~scn_types~] ~filename~]... [-c ~cmd_line~]

Description :  The Load command reloads the current program, or loads a new
    program if filename(s) are specified.  The desired executable files are
    downloaded to the target and the target is reinitialized.

    ~scn_types~ specifies which section types to load for subsequent files:
                 t = text(code), d = data(initialized data),
                 b = bss(uninitialized data), l = literals(read-only data),
                 s = symbols
               "-no" means load all except the specified section types.
    ~filename~ is the name of an executable file.
    ~cmd_line~ is the arguments to be passed to the target program.

    If no "-[n]o" option is given, the default is equivalent to "-no b".  That
    is, all but bss sections are loaded.

Examples : L -o db  (reload only data and bss sections of current program)
           L -o ts myprog            //load text and symbols of myprog
           L myboot -no s myprog1 myprog2 -o tdbls mymain -c prog arg1 arg2
             (load all sections and symbols of myboot, load all but
             symbols of myprog1 and myprog2, load all of mymain and pass it
             the arguments "prog", "arg1", and "arg2")
.  ln ls
Syntax :  LN[A|O] [ ~filename~ ]...

Description :  The Load Names command reloads symbols for the current
    program, or loads symbols for the specified files.  The new symbols will
    replace any existing symbols by default, or they can be added to the
    existing symbols.

    LN,LNO   Load Names, Overwriting the existing symbol table
    LNA      Load Names, Adding to the existing symbol table

    ~filename~ the name of an executable file whose symbols are to be loaded

    See also "H L"
.  ls
    This command has been replaced by the "ln" command.  See "H LN".
#endif  /* !CDB */
.  m mr mb mh mw md mrb mrh mrw mrd
Syntax : M[R][~type~] ~range~, ~addr~

Description : The Move command moves all data in the specified range to the
    specified destination.  The move normally proceeds from the first location
    in range to the first destination location, one type(width) at a time,
    with the predictable destructive consequences if the destination start
    address is within the source range.  The move will be done in reverse
    (starting from the last source and destination locations) if "R" is
    specified, allowing image moves of overlapping ranges.

    ~type~, which defines object size, has the form : { B | H | W | D }

    ~range~ has the form : [ [ ~addr~ ] L ~number~ | ~addr~ [ ~addr~ ] ]
        See "H RANGE" for more details.

    ~addr~ must not be a register address
        See "H ADDR" or "H EXPR" for valid address forms.
.  mc
#if PPC
   The MC command is not valid/supported on the Power architecture
#else
Syntax : MC [~range~ [,~mc_options~ ]...]

Description : The Memory Configuration command provides the emulator
    with details about your memory system.  It defines a physical memory
    map describing the characteristics of each address range.  The MC
    command controls how the emulator accesses various memory areas.
    It also controls emulator features such as overlay memory and access
    protection alarms.
    Please refer to the manual for a complete description of these options.

    MC with no ~range~ and no ~mc_options~ will display the entire configuration
    table.  MC with just a ~range~ displays the configuration for that ~range~.
    If ~mc_options~ are given, only the entered ~mc_options~ are changed -- all
    others remain unaffected.

    See DO and EO for additional information on emulator configuration.

    ~mc_options~ have the form:

    { DW = [ 8 | 16 | 32 ] }             - Bus/Data Width
    { DMA | JAM | INV }                  - use DMA or instruction jamming (JAM)
                                           to access memory range. INV prevents
                                           access to memory range. DMA mode
               				   may not be support by particular 
                                           processors. 
    { RO | RW }                          - Read only or read/write memory range
    { PWE | PWD }                        - Partial Word access Enable/Disable
#endif
.  mt
Syntax : MT ~range~ [,~test~[,~delay~]] [,{H|V|Q|S}...] [,~repeat~]
    or   MT ~range~, ~loop~ [,~data~] [,~repeat~]

Description : The Memory Test command initiates a test of the target's
    memory system, or one of three "scope loops".

    ~range~ has form : { [ ~addr~ ] L ~number~ } | { ~addr~ [ ~addr~ ] } (See "H RANGE")

    ~test~ is a decimal number specifying the test type; available tests are
        1 - Basic patterns         2 - Walking 1's and 0's
        3 - Rotating address       4 - Inverted rotating address
        5 - Partial word
        8 - Refresh                9 - Default. Each of 1,2,3,4 and 5 in turn.

    ~loop~ is a loop type: 10 = read-only, 11 = Write only, 12 = Write/Read

    ~delay~ is a decimal number specifying the delay time in msec, between
    writes and reads.  It is required only for test 8 (the refresh test).

    ~data~ is a data value to be written (required if loop = 11 or 12)

    H, V, Q, or S specify Halt-on-error, Verbose, Quiet or Silent mode.

    ~repeat~ specifies how many times to run the test.  Default is forever.
#if MON
.  q
Syntax :  Q [ Y ]

Description :  The Quit command terminates execution of the debug monitor
    and returns control to the host operating system.  Because of the
    possibility of mistyping a "+Q" or "-Q" command, the Quit command
    prompts for confirmation before actually exiting the program.  This
    prompt can be avoided by supplying the confirming "Y" on the command line.
#endif  /* MON */

.  r rt rp
Syntax :  R[ T | P ]

Description :  The Reset Processor (RP) command does a soft reset of the
    processor core, either by scanning a reset request in via JTAG, or by
    simulating the effects of a reset.

    The Reset Target (RT) command resets the target system by asserting the
    system reset pin on the debug connector.  The RT command is not typically
    used directly, rather it is used within the reset scripts defined in the
    target initialization script file.  The RTNI script uses RT to reset the
    target and then does no initialization, whereas the RTI script uses RT
    to reset target and then runs the target initialization script.

    The default Reset (R) command does an RP or RT, depending on the value
    of the ICE_Reset_Output option (see "H EO" and "DOV iro").
#if API

    Note: Using these reset commands in the Sourcery CodeBench probe console
          is not generally recommended.
#endif
.  return
Syntax :  RETURN

Description :  The Return command is valid only within command files (.maj) and
    cause the current command file call to return exit proccessing of commands
    in the current context and return to the caller.
#if MON
.  s  so sf sv  sq sfq  soq  sfv  sov
Syntax :  S[ O | F ][ Q | V ] [ =~addr~ ] [ ~number~ ]  [ "{" ~cmd_list~ "}" ]
	  SR[ O | F ] [ =~addr~ ] {~code_range~ [,~code_range~]… } ["{" ~cmd_list~ "}"]

Description :  The Step command executes <number> instructions (default is 1)
    starting from <addr> (default is the current execute address). Execution
    terminates after <number> instructions or when a breakpoint is encount-
    ered.  If a command list is given, it is executed every time execution or
    stepping stops.  It remains in effect until cancelled by a Step or Go
    command with an empty command list (e.g. "S {}").  A Step command may be
    repeated by hitting the <enter> key, UNTIL some other command is entered.

    SR is the step range command.  See "H SR" for help on step range. 

    O - Step Over - steps over trap handlers and function calls.
    F - Step Forward - allow pending interrupts to complete and then step.

    V - Verbose mode - each instruction is displayed before it is executed.
    Q - Quiet mode - instructions are not displayed before execution.
        Q/V default is the mode of prior Step (with Q the initial default)

    ~addr~ must be an address in a valid code address space.
        See "H ADDR" or "H EXPR" for valid address forms.

    ~number~ is decimal by default.     See "H NUM" for available number forms.

    ~cmd_list~ is any valid command list.

    ~code_range~ is a ~range~ in instruction space.
.  sr sro srf
Syntax :  SR[ O | F ] [ =~addr~ ] { range [, range]... }  [ "{" cmd_list "}" ]

Description :  The Step Range command executes (steps) instructions while the 
    PC is within a provided set of ranges starting from the current PC or 
    <addr> if given. If a command list is given, it is executed every time 
    execution (stepping) stops.  It remains in effect until cancelled by a Step
    or Go command with an empty command list (e.g. "SR {}"). 

    O - Step Over - steps over trap handlers and function calls.
    F - Step Forward - allow pending interrupts to complete and then step.

    ~addr~ must be an address in a valid code address space. See "H ADDR" or
    "H EXPR" for valid address forms.

    ~code_range~ is an address range in a valid code address space. See 
    "H RANGE" for more details

    ~cmd_list~ is any valid command list.
#endif
.  shift
Syntax :  SHIFT [ ~n~ ]

Description :  The SHIFT command alters the normal correspondence between
   p_values supplied on an FR C command and the parameters for which they are
   substituted.  Normally, p_value1 is substituted for $$1 and so forth.  The
   SHIFT command in effect increments a "cumulative shift count", which is
   added to the parameter number before any substitution is done.  Thus if
   "SHIFT 2" has incremented the "cumulative shift count" to 4, p_value5 is
   substituted for $$1 (instead of p_value1) and so forth.

   ~n~   is the amount by which to increment the "cumulative shift count".
         Default is 1.

   SHIFT also impacts the evaluation of the special parameter $$0, by causing
   it to count remaining p_values starting with the p_value which will be
   substituted for $$1.
#if !API
#if TV_CONCURRENT
.  sp
Syntax :  SP

Description :  The Stop Program command halts a currently executing program in
    interactive mode.  Interactive mode is entered via the go interactive
    (GI) command.  This mode allows a subset of debugger commands to used
    while the program is still running.

    See "H INTERACTIVE" for more details.
#endif
#endif
.  unshift
Syntax :  UNSHIFT [ ~n~ | * ]

Description :  The UNSHIFT command decrements the "cumulative shift count".
    See "H SHIFT" for details of parameter shifting.

    ~n~   is the amount by which to decrement the "cumulative shift count".
          Default is 1.

    *   is a special argument which cancels any shifting currently in effect.
          It resets the "cumulative shift count" to zero.
#if !CDB
.  v vl
Syntax :  VL [[-[n]o ~scn_types~] ~filename~]...

Description : The Verify command is used to verify a program load.

    When no arguments are specified the section types previously downloaded
    are uploaded and checked against the original COFF files.  Otherwise,
    specific section types of specific files can be verified.

    ~scn_types~ specifies which section types to verify for subsequent files:
                 t = text(code), d = data(initialized data),
                 b = bss(uninitialized data), l = literals(read-only data)
               "-no" means verify all except the specified section types.
    ~filename~ is the name of an executable file.

    If no "-[n]o" option is given, the default is equivalent to "-no b".  That
    is, all but bss sections are verified.

Examples : VL         // Verify that a download was successfull
           VL -o tl   // Verify that code and read-only data have not been
                      // corrupted by program execution
#endif
#if !API
#if CDB LX8000
.  vc
#ifall CDB !LX8000
Syntax :  VC [ EXEC | <thread_name> ]

Description : The View Context command is used to either set the debugger's
    view to a particular thread context or display current 
    context information (no args).  The keyword EXEC causes the executing 
    cpu context to be selected (if any), or your executing rtos thread to 
    be selected. Note that this command is only supported if if a
    suitable rtos_api.dll has been setup to match your operating system.

    ~thread_name~ is the name of a particular thread whose context is to
    be selected. Please note that ~thread_name~'s is only supported if a
    suitable rtos_api.dll has been setup to match your operating system.

    Changing the context effects the display of the general (r0 - r31) and
    pc registers.  This generally results in a different call stack walk-back
    (C command).  Note that this command only effects the view context
    and does not change the actual execution context.  A Step or Go command
    following a context change does not start from the location display
    by the PC register.  Instead it starts from the execution contexts
    PC register.
#endif
#ifall CDB LX8000
Syntax :  VC [ 0 .. 7 | EXEC | <thread_name> ]

Description : The View Context command is used to either set the debugger's
    view to a particular CPU context, thread context, or display current 
    context information (no args).  The keyword EXEC causes the executing 
    cpu context to be selected (if any), or your executing rtos thread to 
    be selected. 

    ~thread_name~ is the name of a particular thread whose context is to
    be selected. Please note that ~thread_name~'s is only supported if a
    suitable rtos_api.dll has been setup to match your operating system.

    Changing the context effects the display of the general (r0 - r31) and
    pc registers.  This generally results in a different call stack walk-back
    (C command).  Note that this command only effects the view context
    and does not change the actual execution context.  A Step or Go command
    following a context change does not start from the location display
    by the PC register.  Instead it starts from the execution contexts
    PC register.
#endif
#ifall !CDB LX8000
Syntax :  VC [ 0 .. 7 | EXEC ]

Description : The View Context command is used to either set the debugger's
    view to a particular CPU context, or display current context information.
    The keyword EXEC causes the executing cpu context to be selected.
#endif

    Changing the context effects the display of the general (r0 - r31) and
    pc registers.  This generally results in a different call stack walk-back
    (C command).  Note that this command only effects the view context
    and does not change the actual execution context.  A Step or Go command
    following a context change does not start from the location display
    by the PC register.  Instead it starts from the execution contexts
    PC register.

#endif
#endif /* !API */
.  w
Syntax :  W [ ~n~ ]

Description :  The Wait command waits for ~n~ milliseconds before continuing
    command processing.  If ~n~ is not specified, the default is 100
    milleseconds.  Wait can be used to introduce delays in the playback of
    debugger command files.

#if TV_TRACE
.  + +h +q +t +te +tf +stepcmd enable activate
#else
.  + +h +q +tf +stepcmd enable activate
#endif
#if MON
Syntax :  + Q                             + B [ * | ~addr~... ]
          + STEPCMD
#else
Syntax :  + Q
#endif
#if TV_TRACE
#if MEP
          + TE                            + F [ * | ~filter_list~ ]
#else
          + T[ E ]                        + F [ * | ~filter_list~ ]
#endif
          + TF { ~f_name~ | ~s_name~ } [ m={R|F|RF} ]
#endif
#if MIPS
          + H
#endif

Description :  The Enable command enables the entity or operating mode
    specified by the first keyword:

    Q   indicates Quiet mode of command file playback is to be enabled.
#if MON
    B   indicates breakpoints are to be enabled. ( See "H +B" ).
    STEPCMD turns on single stepping on command script file playback 
#endif
#if TV_TRACE
#if MEP
    TE  indicates Tracing is to be enabled during execution.
#else
    T   indicates Tracing is to be enabled immediately (Logic Analyzer mode).
    TE  indicates Tracing is to be enabled during execution. (See "H +T")
#endif
    F   indicates Filtering is to be enabled or particular Filters are
           to be activated for Display Trace commands.  ( See "H +F" )
    TF  enables the specified Trace format for the current or specified
           trace display mode
#endif
#if MIPS
    H   enables display of hardware register names rather than software names.
#endif
#if TV_TRACE
#if TV_TC3D TV_TCIM
.  +t  +te
Syntax :  + T[ E ]

Description :  The Enable Tracing command enables tracing either
    immediately or ONLY during execution.

    T  indicates Tracing is to be enabled immediately (Logic Analyzer mode).
       Note that a Trace Control specification (e.g. trace only if DREQ or
       DRDY is active) is required.  Tracing will remain enabled until a DT
       command or a -T command disables it.  An explicit +T command is
       needed to re-enable tracing after a -T or DT command, or to download
       a modified Trace specification.

    TE indicates Tracing is to be enabled during execution.  In this mode,
       tracing will be turned on and off, and modified Trace specifications
       will be downloaded automatically in response to Go and Step commands.

#endif /* TV_TC3D TV_TCIM */
#endif /* ICE */
.  - -h -t -q -tf -stepcmd disable
#if MON
Syntax :  - Q                             - B [ * | ~addr~... ]
          - STEPCMD
#else
Syntax :  - Q
#endif
#if TV_TC3D
          - E { * | ~event_list~ }
#endif
#if TV_TRACE
#if MEP
          - TE                            - F [ * | ~filter_list~ ]
#else
          - T                             - F [ * | ~filter_list~ ]
#endif
          - TF { ~f_name~ | ~s_name~ } [ m={R|F|RF} ]
#endif
#if MIPS
          - H
#endif

Description :  The Disable command disables entity or operating mode
    specified by the first keyword:

    Q   indicates Quiet mode of command file playback is to be disabled.
#if MON
    B   indicates breakpoints are to be disabled.  ( See "H -B" )
    STEPCMD turns off single stepping on command script file playback 
#endif
#if TV_TRACE
#if MEP
    TE  indicates that Tracing mode is to be disabled
#else
    T   indicates that the current Tracing mode is to be disabled
#endif
    F   indicates Filtering is to be disabled or particular Filters are
           to be deactivated for Display Trace commands. ( See "H -F" )
    TF  disables the specified Trace format for the current or specified
           trace display mode
#endif
#if MIPS
    H   disable displaying hardware register names rather than software names.
#endif
#if TV_TRACE
.  +f -f
Syntax : {+|-}F  [ * | ~filter_list~ ]

Description : Enable(+) or disable(-) Filtering  or
              activate(+) or deactivate(-) a list of Filters.

    When invoked with no operand(s), Filtering is enabled or disabled.

    *  indicates that all filters are to be activated or deactivated.
    ~filter_list~ specifies specific filters to be activated or deactivated.
        (See "H LIST")

#endif /* TV_TRACE */
#if MON API
.  -b +b
Syntax : {+|-}B  [ * | { # ~number~ | ~addr~ }... ]

Description : Enable or disable a list of breakpoints.

    When invoked with no operand(s), the software breakpoint at the current
    PC will be enabled or disabled.

    *  indicates that all breakpoints are to be enabled or disabled.
    ~addr~ gives the address of a specific software breakpoint to be
        enabled or disabled.
    ~number~ gives the breakpoint ID number (as shown by BL) of a specific
        software or hardware breakpoint to be enabled or disabled.

#endif /* MON */
#if MON
.  !
Syntax :  ![ os_command ]

Description :  The Execute OS shell command allows the user to execute a
    host operating system command without having to exit the debug monitor.
    ! must be either last or alone in a multi-command cmd_list.  Also,
    attempts to insert debug monitor comments within the os_command will result
    in them being sent to and interpreted by the operating system with the rest
    of the os_command text.

    os_command is any valid operating system command.  If it is not supplied,
        a command shell is started up and you can execute any number of
        host commands, finally returning to the debugger by executing the
        "exit" OS command.

#endif  /* MON */
#if !CDB
.  dn en kn
Syntax :  [D|K]N { * | symbol | partial_symbol* }
              EN symbol = ~addr_expr~

Description :
   Display, Kill, or Enter Names (symbols).  '*' is a wildcard character and
   can be given alone or at the end of a partial_symbol.

   symbol is a global data, function, or entered (with EN) symbol.

   partial_symbol is the starting characters of global data, function, or
   entered (with EN) symbol.

#endif /* !CDB */
.  addr address register registers
Syntax :
    memory:   {{~number~|(~addr_expr~)}[:~space~] | @[.~digit~]~addr~[:~space~] | ~sym_name~}
    register : [.]{~register_name~[.]<~field~>}
    other :    {$~ident~}

Description :  The ~addr~ operand is used to specify a register or memory
    address.  The address will be aligned to a word boundary for word or
    double word objects, and to a half-word  boundary for half-word objects.
    ~number~ or (~addr_expr~) provides the offset portion of the address
    including an optional space qualifier.  If ~space~ is supplied, it must be
    valid for the command being invoked. @~addr~ causes an address to be fetched
    from the location specified by ~addr~. @.~digit~ ~addr~ causes ~digit~ bytes
    (1,2,4, or 8) to be fetched from ~addr~. ~sym_name~ is a global or static
    symbol, and implies both address space and offset.

#if ARM
    ~register_name~ may be preceded by a dot to avoid ambiguity with symbolic
    names, which normally take precedence.  Registers shown below that end
    with ~abort~, ~undef~ or ~user~ can be abbreviated as show in the ARM Arch. Ref
    Manual as ~abt~, ~und~, and ~usr~ respectively.  Note that ~r8~ - ~r14~, ~sp~, ~lr~, 
    and ~spsr~ are mode specific registers.  This means they can refer to 
    different banks of registers depending on the current execution mode.

        ~r0~-~r15~, ~sp~ (r13), ~lr~ (r14), ~pc~ (r15), ~cpsr~, ~spsr~ 
        ~r8_user~-~r14_user~, ~r8_fiq~-~r14_fiq~
        ~r13_svc~, ~r13_abort~, ~r13_undef~, ~r13_irq~
        ~r14_svc~, ~r14_abort~, ~r14_undef~, ~r14_irq~
        ~spsr_svc~, ~spsr_abort~, ~spsr_undef~, ~spsr_irq~, ~spsr_fiq~

    The following generic names for Coprocessor registers are also valid:
        cC_R, cC_R_oO_M
    where C is the CP number (0-15), R is the register number (0-15, the CRn
    field of the CP move instructions), O is the Op2 field (0-7), and M is the
    CRm field (0-15).
#endif
#if PPC
    ~register_name~ may be preceded by a dot to avoid ambiguity with symbolic
    names, which normally take precedence.  Many special purpose registers 
    (spr's) also have documented names.  Most of these names are supported.  
    Additional names can alsup be added by editing the debuggers register 
    definition files.  The ict (instruction and data cache tag registers) 
    range (0..X) depends on the cache and cache line size for a given chip.  
    Similarily, the tlb or slb register range depends on the number of 
    supported tlb registers.

        ~r0~-~r31~, ~fpr0~-~fpr31~, ~spr0~-~spr1023~, ~dcr0~-~dcr1023~, ~pc~, 
        ~tb~, ~cr~, ~msr~, ~fpscr~, ~ict~0..X, ~dct~0..X, ~tlb~0..X, ~slb~0..X,
	~sp~

    ABI convention for Linux:
      r0      Volatile temp
      r1/sp   Stack frame pointer
      r3-r10  Volatile parameter and result(r3/r4)
      r11-r12 Volatile temps (modified durning function linkage)
      r13     Small data area pointer
      r14-r31 Non-volatile (local variables)
      cr      Condition (cr0..cr7: 4 bits wide fields)
              cr0-cr1, cr5-cr7 (volatile)
              cr2-cr4 (non-volatile)
      lr      Link Register
      ctr     Count
      xer     Integer exception
#endif
#if MIPS
    ~register_name~ may be preceded by a dot to avoid ambiguity with symbolic
    names, which normally take precedence.  Some registers also conflict with
    addresses (a0 for example). In this case, register names take precedence,
    and the address must be entered as 0xA0.  Valid general and coprocessor
    register names are: (hi-lighted)
        ~r0~-~31~, ~zero~, ~at~, ~v0~-~1~, ~a0~-~3~, ~t0~-~9~, ~s0~-~8~, 
        ~k0~-~k1~, ~1~, ~gp~, ~sp~, ~ra~, ~mdhi~, ~mdlo~.
#if HAS_TLB
        context(~ctxt~), ~index~, random(~rand~), entrylo(~tlblo~), entryhi(~tlbhi~),
        ~tle~#, ~tlo~#, ~th~#, ~tm~#  (TLB "registers", where # is entry number)
#endif
#if ICACHE_TAGS DCACHE_TAGS
        ~ict~#, ~dct~#  (I&Dcache tags, where # is entry number (0-N))
#if ICACHE_PARITY DCACHE_PARITY
        ~icp~#, ~dcp~#  (I&Dcache parity bits, where # is entry number (0-N))
#endif
#endif
        ~c~#~_0~ - ~c~#~_31~, ~g~#~_0~ - ~g~#~_31~ (where # is ~0~..~3~).
	Parts supporting DSP ASE:  ~mdhi1..3~, mdilo1..3, dspctl
#if FPU_SINGLE FPU_DOUBLE
        ~fcr0~, ~fcr31~  (floating point control registers)
    The floating point data register ~g1_0~ - ~g1_31~ can also be referred to by
#if FPU_SINGLE
        ~f0~-~f31~ (single precision).
#else
#if FPU_EVEN
        ~f0~-~f30~ (single precision), ~d0~-~d30~ (double precision) -- even # only.
#else
        ~f0~-~f31~ (single precision), ~d0~-~d31~ (double precision).
#endif
#endif
#endif
    ~field~ refers to registers that have fields. (See "H FIELD" for details)
#endif  /* MIPS */

    $~ident~ is a debugger local variable or option reference. Option enum 
    values can be referenced as $<option_name>.<enum_name>. (See "H VAR" for 
    details on debugger local variables or option references)
.  cmd  cmds cmd_list command commands
Syntax :  ~command~ [ ; ~command~ ] ...

Description :  The ~cmd_list~ operand specifies one or more commands to be
    executed.  The debugger accepts command lists, as well as simple commands,
    in response to the main prompt or when playing back a command file.  In
    this case the commands are executed immediately.  Some commands also
    accept a cmd_list enclosed in curly-braces as an operand (See "H BS",
    "H S", or "H G").  In this case, the list of commands is stored and
    executed later.

    ~cmd_list~ may also contain "C" style comments.  See "H COMMENT".

    The "L" and "!" commands MUST be either last or alone in a cmd_list.

.  expr  addr_expr  value  op  operator
Syntax :  ~addr~ [ ~op~ ~addr~ ]

Description :  An ~addr_expr~ is an expression that evaluates to an address,
    consisting of addrs, operators and other addr_exprs.
    A ~value~ is an ~addr_expr~ without address space information.

    Supported operators(~op~) are (in precedence order):

                ()              Parenthesized sub-expressions
                + - ~~ !         Unary plus and minus, complement, logical NOT
                * / %           Multiply, Divide, Modulo
                + -             Add, Subtract
                << >>           Left shift, Right shift
                < <= > >=       Relationals
                == !=           Equals, Not equals (operands can be strings)
                &               Bitwise AND
                ^               Bitwise XOR
                |               Bitwise OR
                &&              Logical AND
                ||              Logical OR

    Note that no symbol type information is available.  All numeric operands
    must be integer, all arithmetic is performed unsigned long, and symbols
    evaluate to their address (unless preceded with an '@', as always). Some
    symbols are scalar values and evaluate to their constant value. An option
    enum reference is a good example: $<option_name>.<enum> evaluates to the
    referenced enum's scalar value.
#if MIPS
.  field
Syntax :
    field : {~field name~}

Description :
    Most control registers have ~field names~ (e.g. sr.bev) that may be
    referenced directly on Display and Enter commands.  In expressions, field
    names are only meaningfull when used with the '@' operator to get the
    field value.  Also, Enter commands referencing field names must
    be immediate, not interactive (e.g. e sr.bev = 1).

#endif  /* MIPS */
.  fmt  format
Syntax :  { d | u | o | x | X | f | e | E | g | G | c | s | i }

Description :  The ~fmt~ operand specifies the format for display and
    entry with the Display and Enter commands, as follows :

    d     Signed decimal integer
    u     Unsigned decimal integer
    o     Unsigned octal integer
  x | X   Unsigned hexadecimal integer                     Default is "X"
    f     Signed floating point value in decimal notation,
             with six decimal places
  e | E   Signed floating point value in scientific notation,
             with six decimal places
  g | G   Signed floating point value in either decimal or scientific
             notation, whichever is more compact
    c     Single ASCII character
    s     Character string, terminated by the first null character
    i     Assembled/disassembled instruction

    The case of the x, e, and g formats determines whether alphabetic
    characters in the formatted data will be in upper or lower case.
    The fmt operand is the sole exception to the rule that keywords are not
    case-sensitive in monitor commands.
#if TV_TRACE
.  fmt_options
Syntax :  [key = value]

Description:  ~fmt_options~ are used to modify the trace format.  The options
    with an '*' next to them are changeable for default formats.  Be aware
    that default formats in one list, may be user-defined in the other list.

---KEY = VALUE--------------FULL NAME--------------DEFAULTS-----------
  hs = string               Header String     Its ~f_name~ or ~s_name~
 *ib = ~f_name~ or ~s_name~      Insert Before     The end of the format list
 *ia = ~f_name~ or ~s_name~      Insert After      The end of the format list
   s = any character        Separator         '=', or same polarity as ~f_list~
                                              if ~f_list~ is an f_atom
 * r = {2|8|10|16}          Radix             16 (The radix can only be
                                              changed for an ~f_name~, not an
                                              ~s_name~)
 * e = {t|f|y|n|+|-}        Enabled           Active
 * m = {r|f}                Mode              Based on the current trace
                                              display mode: RAW if raw mode,
                                              FORMATTED if inst, data, or mixed
                                              modes
 *va = ~color~                Video Attributes  DEFAULT
  ho = {h|v}                Header Orientaion MON will determine this based on
                                              the column width and header size
 *bb = ~number~               Blanks Before     0 if column width = 1, 1 if
                                              multi-column
 *ba = ~number~               Blanks After      0
 *cw = ~number~              Column Width      As calculated for the f_name.
NOTE: All the options must be correct in order for the command to be
      processed.
#endif
.  mask
Syntax :   { ~number~ }
Definition :  Selects the bits of the field or number to be evaluated.  A mask
    bit with a value of one means the corresponding bit of the field is
    selected.  A mask bit with a value of zero means the corresponding bit
    of the field is ignored.  If mask is omitted, all bits of the field
    are selected. Default base for mask is hexidecimal.

#if TV_TRACE
.  list  cond_list  state_list  event_list filter_list
Syntax:    { ~number~[:~number~] }...
           { F~id~[:~id~] }...

Definition :  The list operand is used to define a group of filters
              to a command.

    F~id1~[:~id2~] is a shorthand form denoting all the filters
        starting with entity ~id1~ and concluding with entity ~id2~.

        e.g.  F2:6 expands to  F2 F3 F4 F5 F6

    ~number~[:~number~] may ONLY be used when there is absolutely no
    ambiguity about what type of entity is being referenced, as in the KILL
    command.  There, the shorthand expansion works similarly on 2:6.
#endif /* TV_TRACE */
.  num  number
Syntax :   [ 0{ o|O } | 0{ n|N } | 0{ x|X } ]~dddddddd~

Description :  The number operand is used to indicate a count or the offset
    portion of an address to a command.

    ~dddddddd~  is a series of digits in the current default number base,
              or in an explicit number base, determined by the first
              one or two characters preceding the digits.

    0{ o|O }  Octal
    0{ n|N }  Decimal
    0{ x|X }  Hexadecimal

    Default number base in ~addr~ or ~addr_expr~ is usually hexadecimal.
    Default number base elsewhere is usually decimal.

#if PPC
.  p
Syntax :  P cmd verbosity

Description :  Enable diagnostic messaging

    0x0001 Error messages
    0x0002 Execution control (reset, stepping, going, breakpoints...)
    0x0004 Target Status
    0x0008 Memory Management (MMU) related messages
    0x0040 Target data transfers (reads and writes to memory and registers)
    0x0100 CCS Startup and Control Logic
    0x0200 CSS Debug API
    0x1000 Enable diagnostic messages to the console
    0x4000 Prepend a timestamp to all diagnostic messages
    0x8000 Flush buffer (ensures each message is emitted entirely before
           proceeding)
#endif
.  param  parameter  parameters  p_value
Syntax :  $${ ~n~ | 0 | * }

Description :  The parameter is a place-holding token in a ~command~ file.
    When SHIFT is not in effect, p_value1 is substituted for $1, p_value2
    is substituted for $2 and so on.  If there is no p_value corresponding
    to a particular parameter, the parameter will simply be removed from
    the command line during parameter substitution.


    $$~n~   is the user-definable form of parameter.  n may range from 1 to 99.
             See "H FRC" and "H SHIFT".

    $$0   is a special parameter and evaluates to the number of p_values
            remaining to be processed.  This evaluation reflects any shift
            that may be in effect.

    $$*   is a special parameter and evaluates to the entire list of p_values
            as supplied on the File Read ( FR C ) command.  This evaluation is
            NOT affected by SHIFT.

    If you wish to use a parameter as part of a larger token, you must "paste"
    it to the non-parameter part of the token.  This "pasting" is done with
    the backslash character.
    Examples are:  $$1\3     MY\$$2\IDENT    temp\$$3

.  range
Syntax : [ *[:~space~] | { [ ~addr_expr~ ] L ~number~ | ~addr_expr~ [ ~addr_expr~ ] } ]

Description :  The range operand specifies the location of one or more
    objects in the memory address spaces or the registers for the Display
    and Enter commands.

    The range begins at the first ~addr_expr~. If no ~addr_expr~ is supplied, the
    range begins where the range of the previous Display or Enter command
    left off, or at 0 if it is the first Display or Enter command.

    If L ~number~ is specified, the range continues for number objects.

    If ~addr_expr~ ~addr_expr~ is specified, the range continues through to the
    object at the second addr_expr.

    If neither L ~number~ nor second ~addr_expr~ is supplied, the range consists
    of a default number of objects.

    *[:~space~] is a special way of matching all addresses. Generally, this
    translates to the range 0 - FFFFFFFF in the default or given space.

#if TV_TRACE
.  s_name sname
Syntax : {frame | timestamp | rw_flag | label | location | value | description}

Description :  ~s_name~ specifies one of the special names used by trace format.

       frame        The frame number
       timestamp    Timestamp indicator
       rw_flag      Data direction indicator
       label        Code symbolic information
       location     Synthesized address value (data or inst)
       value        Contents of the inst or data bus - whichever is valid
#if MIPS_3K
       valid        Valid, Invalid, or Not sure for each cache block read.
#endif
       description  More information about the access, depending on the
                    trace display mode. Examples are disassembled instructions,
                    and data access descriptions

#endif /* TV_TRACE */
.  space 
Syntax :
    ~space~ : default             -- Data/Instruction
#if TV_DASPACE
    ~space~ : { IN | P | DA }     -- Real Address Spaces
#endif
#if PPC
    ~space~ : { IN | P | S | E }  -- Real Address Spaces
#else
    ~space~ : { IN | P}		  -- Real Address Spaces
#endif
    ~space~ : LP                  -- Address Translation Space  

Description : ~space~ tells the debugger to use the given real space.
    An address given with no space defaults to normal instruction/ 
    data space.  

            IN = Instruction Space
            P  = Physical Memory
#if TV_DASPACE
            DA = Debug Agent memory
#endif
            S  = SAP Memory (Internal SAP access mode - bypass caches)
            E  = ELF Memory (Internal ELF access mode)
            LP = Logical to Physical address translation

    The IN space typically is not needed to qualify addresses as most PowerPC 
    MMU configurations are setup to map instruction and data memory as the
    same address space (MSR.DS == MSR.IS).  IN can be used when this is not 
    the case.
   
#if TV_DASPACE
    The DA space does not correspond to actual target memory.  It is
    an address space that allows arbitrary data to be passed to or from the
    "debug agent" (the probe firmware or debug kernel).

#endif
    The LP space does not correspond to actual target memory.  It is
    an address space that allows a virtual to physical address translation
    to be performed.  When a word is read from a :LP address, the MAJIC
    looks up the virtual address in the targets TLB/MMU tables and if the
    lookup is successfull it returns the resulting physical address as the
    data.
.  t
#if PPC
                        ~Target connection commands~

   TC   Connect to target
   TD   Disconnect from target
   TS   Show target connection status
#endif
.  tc
Syntax :  tc

#if PPC
Description :  The TC (Target Connect) command makes a connection to the
    configured probe and target.  Status is displayed after the the connection
    is made. Status can also be displayed with the ts (target status) command.
#else
Description :  This command is not valid for the current architecture.
#endif
.  td
Syntax :  td

#if PPC
Description :  The TD (Target Disconnect) command disconnects from a connected
    target.
#else
Description :  This command is not valid for the current architecture.
#endif
.  ts
Syntax :  ts

Description :  The TS (Target Status) command displays the current target
    connection status.
.  type
#if ARM
    ~space~ : default            -- Instruction/Data 
#ifall TV_DASPACE ICACHE DCACHE
    ~space~ : { P | D | I | DA } -- Real Address Spaces
#endif
#ifall TV_DASPACE ICACHE !DCACHE
    ~space~ : { P | I | DA }     -- Real Address Spaces
#endif
#ifall TV_DASPACE !ICACHE DCACHE
    ~space~ : { P | D | DA }     -- Real Address Spaces
#endif
#ifall TV_DASPACE !ICACHE !DCACHE
    ~space~ : { P | DA }         -- Real Address Spaces
#endif
    ~space~ : LP                 -- Address Translation Space  

Description : ~space~ tells the debugger to use the given real space.
    An address given with no space defaults to normal instruction/ 
    data space.  

            P  = Physical Memory
#if DCACHE
            D  = Data Cache
#endif
#if ICACHE
            I  = Instruction Cache
#endif
#endif /* ARM */
#if MIPS
    ~space~ : { 0 | 1 | 2 | 3 | R | S | U }   -- 32 bit Virtual Address Segments
    ~space~ : { XU | XS | XP | XK }           -- 64 bit Virtual Address Segments
#ifall TV_DASPACE ICACHE DCACHE
    ~space~ : { P | D | I | DA }              -- Real Spaces
#endif
#ifall TV_DASPACE ICACHE !DCACHE
    ~space~ : { P | I | DA }                  -- Real Spaces
#endif
#ifall TV_DASPACE !ICACHE DCACHE
    ~space~ : { P | D | DA }                  -- Real Spaces
#endif
#ifall TV_DASPACE !ICACHE !DCACHE
    ~space~ : { P | DA }                      -- Real Spaces
#endif
#ifall !TV_DASPACE ICACHE DCACHE
    ~space~ : { P | D | I }                   -- Real Spaces
#endif
#ifall !TV_DASPACE ICACHE !DCACHE
    ~space~ : { P | I }                       -- Real Spaces
#endif
#ifall !TV_DASPACE !ICACHE DCACHE
    ~space~ : { P | D }                       -- Real Spaces
#endif
#ifall !TV_DASPACE !ICACHE !DCACHE
    ~space~ : { P }                           -- Real Spaces
#endif

Description : ~space~ tells the debugger to use the given real space or to
    modify the given address by adding the base address associated with the
    specified virtual segment (~space~).  The base addresses shown below for
    32 bit virtual segments are sign-extended when used with a 64-bit target.
    An address given with no space defaults to an offset in Kuseg. The real
#if ICACHE DCACHE
    spaces allow for reading directly to physcial memory and caches.
#else
    space allows for reading directly to physcial memory.
#endif

            U  = kuseg  (0 - default)        0  = kseg0  (0x80000000)
            1  = kseg1 (0xA0000000)          2  = kseg2  (0xC0000000)
            S  = ksseg (0xC0000000)          3  = kseg3  (0xE0000000)
            R  = ROM (0xBFC00000)            P  = Physical Memory
            XU = xuseg  (0)                  XS = xsseg (0x4000000000000000)
            XP = xkphys (0x8000000000000000) XK = xkseg (0xc000000000000000)
#if DCACHE
            D  = Data Cache
#endif
#if ICACHE
            I  = Instruction Cache
#endif
#endif  /* MIPS */
#if TV_DASPACE
            DA = Debug Agent memory

    The DA space does not correspond to actual target memory.  It is
    an address space that allows arbitrary data to be passed to or from the
    "debug agent" (the ICE firmware or debug kernel).
#endif
            LP = Logical to Physical address translation

    The LP space does not correspond to actual target memory.  It is
    an address space that allows a virtual to physical address translation
    to be performed.  When a word is read from a :LP address, the MAJIC
    looks up the virtual address in the targets TLB/MMU tables and if the
    lookup is successfull it returns the resulting physical address as the
    data.
.  type
Syntax :  { B | H | W | D }

Description :  The type operand specifies the size of objects to be
    displayed, entered or moved, as follows :

                         Valid Formats (~fmt~)
    ~type~   Size          Enter Format           Display Format
    ----   -----------   ------------------     ------------------
      B    Byte          d, u, o, x|X, c, s     d, u, o, x|X, c, s
      H    Half-word     d, u, o, x|X           d, u, o, x|X
      W    Word          any except c or s      any except c or s
      D    Double word   any except c or s      any except c or s

    If ~type~ is omitted from a Display or Enter command, the ~type~ from the
    previous execution of the command is used.  If this is the first
    execution, the default is Word.

    ~type~ on a Move command is used only to scale the object count and to
    round up the source range to include an integral number of objects.

.  var  vars  variable  variables  local  ident
Syntax :  ${ A-Z | a-z | $ | _ }[{ A-Z | a-z | 0-9 | $ | _ | . }]...

Description :  Both options and monitor local variables are referenced with
   a preceding $.  Options have precedence and evaluate to the address of the
   option.  Monitor (debugger) local variables provide temporary storage which
   does not impact the target memory. Either type may appear anywhere an ~addr~
   operand is required.  There are a few built in debugger variables useful for
   scripts:
	$INIT_TYPE  : 0 normal startup, 1 non intrusive startup
        $CPU_ID     : Debuggers internal CPU ID number. 
        $CPU_FAMILY : 1 = PPC, 2 = MIPS, 4 = ARM

   Debugger local variables are created at reference time.  A warning is output
   at creation type if the access is a reference rather than explicit set. Note
   that the creation time, the referenced size determines the debugger local
   variable size.  
   example:
	MON> dw $foo
	Warning: Creating debugger local variable $foo on reference
	$foo:  00000000

   Use the enter command to create and/or assign the value of debugger local 
   var:
	MON> ew $foo = 0x12345678
	MON> dw $foo
	$foo:  12345678

   Note that debugger local variables are case sensitive and the address of a 
   debugger local variable is an offset within a reserved memory area of MON. 
   Below is a reference expression to an address (0x260) and it's corresponding
   indirection value. Note that the address is also displayed above, but is 
   converted to the corresponding variable name
   \"$foo\":
	MON> dv "%x = %x\n", $foo, @$foo
	260 = 12345678

   '@' is an indirection (dereference) operator.  MON does not keep 
   type/size information, so all references must reference the size of the 
   object. The default size is a word for '@' indirection references. 

   
 
.  color
Syntax :
    color : { color_keyword | DEFAULT }

Description :  The monitor's color display is implemented using ANSI escape
    sequences as defined in the MS-DOS ANSI.SYS documentation.  The color
    names are also taken from this documentation except that the "B_" names
    are the color given plus the bold attribute is applied.  The REVERSE
    option has the effect of black on white background.

    The selection of DEFAULT will apply the color specified for the
    dp_color_output option.  Invoke "DOV dco" for default and color_keywords.

    LINUX NOTE: Color support requires an ANSI-compatible display or
    terminal emulation, like VT220.

.  comment comments
Syntax :  { /* [*/] | // }

Description:
   Comment syntax and rules loosely match "C" comment conventions with
   the following exceptions:  Comments cannot span multiple lines (e.g.
   a new comment opener must be used for each line).  The ending */
   is optional, and one is assumed if not found.  Note that /* */ can
   enclose a semicolon (command separator).  // causes the rest of the
   line to be ignored.

#if !CDB
.  edit line cursor  buffer
Command line editing and history keys:

    ~KEY~         ~FUNCTION DESCRIPTION~
    <Ins><C-T>   (Insert) Toggles between Insert and Overtype modes.  In 
                 Insert mode, normal characters are inserted at the current 
                 cursor position.  In Overtype mode, normal characters 
                 replace the character at the current cursor position.
                 On MS-DOS systems, the cursor size reflects the mode. Insert
                 mode is a half-field block, overtype mode is an underline.
                 Unix systems do not support cursor size changes. Insert mode
                 is also controllable via the EO option edit_insert_mode.
    <Del><C-P>   (Delete) Deletes the character at the current cursor position.
    <BS>         (Backspace) Deletes the character in front of the current 
                 cursor position.
    <Up><C-K>    (Up Arrow) Replaces the current line (if any) with the 
                 previous line in the circular buffer.
    <Down><C-J>  (Down Arrow) Replaces the current line (if any) with the 
                 next line in the circular buffer.
    <Left><C-N>  (Left Arrow) Moves the cursor to the left one character.
    <Right><C-L> (Right Arrow) Moves the cursor to the right one character.
    <Home><C-W>  Moves the cursor to the beginning of the current line.
    <End><C-E>   Moves the cursor to the end of the current line.
    <PgUp><C-V>  (Page Up)  Replaces the current line (if any) with the first 
                 (oldest) line in the circular buffer.
    <PgDn><C-B>  (Page Down)  Replaces the current line (if any) with the last 
                 (youngest) line in the circular buffer.
    <C-PgUp>     (Control-Page Up) Deletes the entire contents of the circular 
                 buffer.
    <C-PgDn>     (Control-Page Down) Deletes the currently selected line (if 
                 any) from the circular buffer.
    <Esc><C-C>   (Escape) Deletes all text from the current line.  The circular
                 buffer is not affected.
    <Enter>      (Return) Enters the current line as input to MON.  The 
                 cursor does not have to be at the end of the line.
    <F1><C-F>    (Function key F1) Entered once, searches the circular buffer 
                 for a line whose beginning matches the text typed so far. The
                 search starts from the last (youngest) entry in the buffer.  
                 If a match is found, the matching line replaces the current 
                 line.  If a match is found, <F1> can be hit again to find the 
                 next match for the original text.
    See "H history" for help on the debugger's history file.
    Note that on Unix consoles, some of the keys require you to be in a
    specific shell mode.  See "H UNIX" for details.
.  history startedb startedb.hst hst
~Debugger History/History File:~
    The debuggers maintain a history file called ~majic.hist~ that 
    contains the current command history from your last debug session.  This
    file is read in at debugger startup time, and written out upon exiting.
    Any new command input line (from the keyboard) longer than two characters
    is added to the history buffer, pushing out the oldest command (if 
    necessary).

    The history file is searched, like any other file the debuggers operate on,
    via the following method. First, the current directory is searched, 
    followed by each directory in the path environment variable. For each 
    directory searched (assuming file not found) we also search the be or le
    (big/little endian) subdirectory.  If a history file is not found a new 
    one is created in the current directory upon exit.  A default (empty) 
    history file is provided in the bin directory with the debuggers.  
    Typically this is sufficent for most users, but if you're using a shared 
    bin directory you might want to create your own history file in a 
    private directory.  The private directory must be in the search path for
    the debugger to find it.  DOS Users: The history file will not be updated,
    if during your MON session you changed the current directory and the, 
    orignal current directory was the load location for the history file.
    
    Note that if your setup involves referencing the history file from a 
    shared directory and that directory is read-only or the default history 
    file is read-only you will error at exit time like "ERROR: removing old
    history file..." or, "ERROR: Cannot create temporary history file...".
    To resolve this case, place the history somewhere in your path prior
    to the shared read-only directory.    (See "H EDIT" for command keys)
. linux unix
~Command line editing and history keys on UNIX consoles:~

    Many UNIX consoles have different shell modes which can alter or filter
    out the keyboard codes used for command line editing and history recall.
    If these keys seem not to perform their function try swithing to a 
    different mode.  

#if TV_CONCURRENT
. inter interactive concurrent
~INTERACTIVE DEBUG:~
    
    Interactive debug mode is a feature which allows for the concurrent debug
    and execution of a target program.  For example: one could sample the 
    programs execution behaviour by issuing a "DW PC" command many
    times and examining the changes.

    The two commands that effect interactive mode are GI (go interactive)
    and SP (stop). The SP command is much like hitting CTRL-C on a
    working target.  While in interactive debug mode, some commands are
    not allowed.  Namely, step (S) and calls (C) command.

    MON can also be started up in interactive mode (assuming a target which
    is left running in interactive mode) via the -ni (non-intrusive) command
    line option.

    Note that in interactive mode target program messages that normally go
    to the debug screen will still do so, temporarily interrupting any user
    input that may be in progress.
#endif /* TV_CONCURRENT
#endif /* !CDB */
.  ops  operand  operands
                        ~DEBUG MONITOR OPERANDS~

   operand     op_key

   addr        ADDR       specifies a register or memory address
   addr_expr   EXPR       numeric part of an addr, which may be an expression
   cmd_list    CMD        colon-separated list of commands
#if MIPS
   field       FIELD      register field qualifiers
#endif  /* MIPS */
   fmt         FMT        indicates which format for enter or display
   f_spec      FSPEC      state of the CPU busses and control signals
   label       LABEL      identifies location in a command file
   list        LIST       defines group of states, conditions, events or banks
   mask        MASK       identifies bits of a field or number to be evaluated
#ifall ICE !MIPS 
   mc_options  MC_OPTIONS Memory Configuration options
#endif /* all ICE !MIPS */
   number      NUM        octal, decimal or hexadecimal digits
   p_value     PARAM      value to be substituted for a parameter
   range       RANGE      location of object(s) in memory or registers
   space       SPACE      space qualifier to addresses
   t_fmt       TFMT       trace format specifier name
   type        TYPE       size of objects the command is to manipulate
   $ident      VAR        monitor local variable

.  control  cntrl  file  files
                  ~COMMAND FILE FLOW CONTROL FEATURES~

   GOTO        provides non-sequential reading of a command file.

   [UN]SHIFT   alters processing of parameter substitution in commands.
                 Also see "H FRC" and "H PARAM"



   $ident      monitor local variable, provides temporary storage and
                 does not use any target memory.  See "H VAR".

   $$n         parameter to be replaced with p_value, which is specified
                 via the FR C command.  See "H PARAM".

   $$0         special parameter which evaluates to the number of p_values
                 remaining to be processed.  See "H PARAM".

   $$*         special parameter which evaluates to all p_values supplied
                 via the FR C command.  See "H PARAM".
#if !CDB

~For details on MON's command line edit and history facility - See "H HISTORY"~
~& "H EDIT"~
#endif
.  gen
                        ~DEBUG MONITOR COMMANDS~
#if MON API
  Bx     Breakpoint commands (BC, BL, BS, BS2, BSH)
#endif
#if MON
  C      Call summary.  Displays a summary of current Call stack
#endif
#ifall !TV_TC3D TV_TRACE !CDB
  Dx     Display/Find cmds (D[B|H|W|D|Q],DV,DA,DO,DI,DF,DT[N|F],DN,DM[X])
  Ex     Enter/Fill cmds (E[B|H|W|D|Q],EA,EO,EF,ET{N|F|M},EN)
#endif
#ifall !TV_TC3D !TV_TRACE !CDB
  Dx     Display/Find cmds (D[B|H|W|D|Q],DV,DA,DO,DI,DN,DM[X])
  Ex     Enter/Fill cmds (E[B|H|W|D|Q],EA,EO,EN)
#endif
#ifall !TV_TC3D TV_TRACE 
  Dx     Display/Find cmds (D[B|H|W|D|Q],DV,DA,DO,DI,DF,DT[N|F],DM[X])
  Ex     Enter/Fill cmds (E[B|H|W|D|Q],EA,EO,EF,ET{N|F|M})
#endif
#ifall !TV_TC3D !TV_TRACE CDB
  Dx     Display/Find cmds (D[B|H|W|D|Q],DV,DA,DO,DI)
  Ex     Enter/Fill cmds (E[B|H|W|D|Q],EA,EO)
#endif
  Fx     File Read/Write commands (F, FR, FW)
#if MON
#if !TV_CONCURRENT
  G      Go. Begins execution with optional non-sticky breakpoints
#else
  Gx     Go. (G,GI) Begins execution with optional non-sticky breakpoints
#endif
#endif  /* MON */
  H      Help.  Details selected command or operand (See "H OPS" & "H CONTROL")
  IF     If.  Implements conditional execution of monitor commands
#ifall !TV_TC3D TV_TRACE !CDB
  Kx     Kill commands (KA, KN, KF, KT, KTN, KTF)
#endif
#ifall !TV_TC3D !TV_TRACE !CDB
  Kx     Kill commands (KA, KN)
#endif
#ifall !TV_TC3D TV_TRACE CDB
  Kx     Kill commands (KA, KF, KT, KTN, KTF)
#endif
#ifall !TV_TC3D !TV_TRACE CDB
  K      Kill Alias command
#endif
  Lx     Load commands (L, LN)
#
  Mx     Move commands (M, MB, MH, MW, MD, MR, MRB, MRH, MRW, MRD)
#if ICE
#if MIPS  
  MC     Memory Configuration.  Setup/display of memory configuration.
#endif
  MT     Memory Test.  Runs a test of the target's memory.
#endif  /* ICE */
#if MON
  Q      Quit.  Terminates execution of the Debug Monitor
#endif  /* MON */
  R      Reset.  Resets the CPU core or target system (R, RT, RP)
  RETURN Return. Exits the current maj script call.
#if MON
  Sx     Step.  Executes one or more instructions (S, SF, SO, SQ, SV)
  SRx    Step Range.  Executes one or more instructions (SR, SRF, SRO)
#endif
#ifall TV_CONCURRENT !API
  SP     Stop Program.  Exit interactive mode (GI)
#endif
#if PPC
  Tx     Target Connection (TC|TD|TS)
#else
  TS     Target Status 
#endif
  VL     Verify Load command
  W      Wait command.  Pauses command processing.
#ifall !TV_TC3D TV_TRACE MIPS MON !MEP
  +x     Enable commands  (+Q, +B, +H, +F, +STEPCMD, +T, +TE, +TF)
  -x     Disable commands (-Q, -B, -H, -F, -STEPCMD, -T, -TF)
#endif
#ifall !TV_TC3D TV_TRACE MIPS MON MEP
  +x     Enable commands  (+Q, +B, +H, +F, +STEPCMD, +TE, +TF)
  -x     Disable commands (-Q, -B, -H, -F, -STEPCMD, -TE, -TF)
#endif
#ifall !TV_TC3D !TV_TRACE MIPS MON
  +x     Enable commands  (+Q, +B, +H, +STEPCMD)
  -x     Disable commands (-Q, -B, -H, -STEPCMD)
#endif
#ifall !TV_TC3D TV_TRACE  !MIPS MON !MEP
  +x     Enable commands  (+Q, +B, +F, +STEPCMD, +T, +TE, +TF)
  -x     Disable commands (-Q, -B, -F, -STEPCMD, -T, -TF)
#endif
#ifall !TV_TC3D TV_TRACE !MIPS MON MEP
  +x     Enable commands  (+Q, +B, +F, +STEPCMD, +TE, +TF)
  -x     Disable commands (-Q, -B, -F, -STEPCMD, -TE, -TF)
#endif
#ifall !TV_TC3D !TV_TRACE !MIPS MON
  +x     Enable commands  (+Q, +B, +STEPCMD)
  -x     Disable commands (-Q, -B, -STEPCMD)
#endif
#ifall !TV_TC3D TV_TRACE MIPS !MON !MEP
  +x     Enable commands  (+Q, +H, +F, +T, +TE, +TF)
  -x     Disable commands (-Q, -H, -F, -T, -TF)
#endif
#ifall !TV_TC3D TV_TRACE MIPS !MON MEP !API
  +x     Enable commands  (+Q, +H, +F, +TE, +TF)
  -x     Disable commands (-Q, -H, -F, -TE, -TF)
#endif
#ifall !TV_TC3D TV_TRACE MIPS !MON MEP API
  +x     Enable commands  (+Q, +B, +H, +F, +TE, +TF)
  -x     Disable commands (-Q, -B, -H, -F, -TE, -TF)
#endif
#ifall !TV_TC3D !TV_TRACE MIPS !MON !API
  +x     Enable commands  (+Q, +H)
  -x     Disable commands (-Q, -H)
#endif
#ifall !TV_TC3D !TV_TRACE MIPS !MON API
  +x     Enable commands  (+Q, +B, +H)
  -x     Disable commands (-Q, -B, -H)
#endif
#ifall !TV_TC3D TV_TRACE !MIPS !MON !MEP
  +x     Enable commands  (+Q, +F, +T, +TE, +TF)
  -x     Disable commands (-Q, -F, -T, -TF)
#endif
#ifall !TV_TC3D TV_TRACE !MIPS !MON MEP !API
  +x     Enable commands  (+Q, +F, +TE, +TF)
  -x     Disable commands (-Q, -F, -TE, -TF)
#endif
#ifall !TV_TC3D TV_TRACE !MIPS !MON MEP API
  +x     Enable commands  (+Q, +B, +F, +TE, +TF)
  -x     Disable commands (-Q, -B, -F, -TE, -TF)
#endif
#ifall !TV_TC3D !TV_TRACE !MIPS !MON !API
  +x     Enable commands  (+Q )
  -x     Disable commands (-Q )
#endif
#ifall !TV_TC3D !TV_TRACE !MIPS !MON API
  +x     Enable commands  (+Q, +B)
  -x     Disable commands (-Q, -B)
#endif
#if MON
  !      Runs a host operating system command processor
#endif
  ~file_name~[.~label~] [ ~p_value~ ]....   Call script function
  ~label~ [ ~p_value~ ]....               Call script func in current script
. foo

Dummy entry to make sure that extra new lines at the end of the file do
not mess up any of the real help entries.
